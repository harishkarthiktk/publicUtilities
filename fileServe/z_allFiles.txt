## PROJECT STRUCTURE
‚îú‚îÄ‚îÄ docs
‚îÇ   ‚îî‚îÄ‚îÄ Screenshot.png
‚îú‚îÄ‚îÄ logs
‚îÇ   ‚îî‚îÄ‚îÄ app.log
‚îú‚îÄ‚îÄ serveFolder
‚îÇ   ‚îú‚îÄ‚îÄ sampleFolder
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sample_data2.jpg
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sample_data3.jpg
‚îÇ   ‚îú‚îÄ‚îÄ README.md ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ sample_data.jpg
‚îÇ   ‚îú‚îÄ‚îÄ script.sh ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ upload.txt
‚îú‚îÄ‚îÄ static
‚îú‚îÄ‚îÄ temp_zips
‚îú‚îÄ‚îÄ templates
‚îÇ   ‚îú‚îÄ‚îÄ base.html ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ browser.html ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ error.html ‚úì
‚îú‚îÄ‚îÄ app.py ‚úì
‚îú‚îÄ‚îÄ README.md ‚úì
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ test_app.py ‚úì
‚îú‚îÄ‚îÄ z_allFiles.txt
‚îî‚îÄ‚îÄ z_util_compressProjectFiles.py

## README.md
# Flask File Server
A self-hosted Flask-based utility for quickly transferring files between machines without needing to set up FTP or SMB shares.
![Screenshot](https://raw.githubusercontent.com/harishkarthiktk/publicUtilities/refs/heads/master/fileServe/docs/Screenshot.png "File Serve with Upload Utility")
---
## Current Features
- **File Browser UI**: Explore folder structure starting from a configurable `serveFolder`
- **Folder Support**: Nested directories are rendered and navigable
- **File Download**: Any listed file can be downloaded via the web UI
- **Drag-and-Drop Upload**: Upload single files or entire folder structures
- **Basic Security**: Prevents directory traversal and unauthorized filesystem access
- **Temp Zip Cleanup**: Folders downloaded as ZIPs are auto-cleaned after delivery
- **File Filtering**: Only files with safe extensions (`.txt`, `.pdf`, `.jpg`, etc.) are accepted during upload
---
## Upcoming Features: Admin Info
> (Planned section to appear at bottom of UI)
- **Total file count**
- **Total storage used**
- **Lifespan indicators** for uploaded files (e.g., "uploaded 3 hours ago")
---
## Planned Security Features
- **Access Token in URL** (e.g. `/?token=abc123`)
- **Optional Upload Password**
- **Rate Limiting or Time-Boxed Access**
- **Access logs and audit trail** (optional)
---
## Planned Functional Features
- **Select and Download Multiple Files as a ZIP**
- **Unzip Uploaded ZIP Archives Automatically**
- **QR Code for easy access from mobile devices**
- **Auto-delete old files** (based on file age or max count)
- **Pagination** of the list when the files and folders in the served folder becomes lot.
- **Search** functionality of quickly finding the file/path being searched in the entire listing.
---
## Installation
1. Clone the repository:
```bash
git clone https://github.com/harishkarthiktk/flask-file-server.git
cd flask-file-server
```
2. Create environment & install dependencies:
```bash
python3 -m venv env
source env/bin/activate
pip install -r requirements.txt
```
3. Run the app:
```bash
python app.py
```
Then open [http://localhost:8000](http://localhost:8000) in your browser.
---
## Configuration
Edit these in `app.py` if needed:
| Variable       | Purpose                        |
|----------------|---------------------------------|
| `SERVE_FOLDER` | Root directory to serve files from |
| `UPLOAD_FOLDER`| Where uploads get stored        |
| `TEMP_DIR`     | Folder used to store temp zips  |
| `port`         | Port number (default `8000`)     |
| `host`         | Set to `0.0.0.0` to allow LAN access |
---
## API Endpoints
| Method | Path                       | Description                      |
|--------|----------------------------|----------------------------------|
| GET    | `/`                        | Show browser UI with files       |
| GET    | `/files/<path>`           | Download single file             |
| GET    | `/download-folder/<path>` | Download folder as ZIP           |
| POST   | `/upload`                 | Upload files/folders             |
---
## Considerations
- This is a utility, not a hardened production tool
- Great for LAN use, secure behind firewall/VPN
- Avoid exposing it directly to the internet without hardening
---

## app.py
from flask import Flask, send_file, abort, render_template, request, jsonify, after_this_request
from markupsafe import escape
from werkzeug.utils import secure_filename
import os
from pathlib import Path
import zipfile
import shutil
import atexit
import tempfile
import logging
from logging.handlers import RotatingFileHandler
app = Flask(__name__)
app.config['MAX_CONTENT_LENGTH'] = 5 * 1024 * 1024 * 1024  # 5GB limit
SERVE_FOLDER = Path(r'serveFolder').resolve()
TEMP_DIR = Path('temp_zips').resolve()
UPLOAD_FOLDER = SERVE_FOLDER
ALLOWED_EXTENSIONS = {'.txt', '.pdf', '.jpg', '.jpeg', '.png', '.zip', '.csv', '.json', '.md'}
for folder in [SERVE_FOLDER, TEMP_DIR]:
    try:
        folder.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        print(f"Failed creating folder {folder}: {e}")
log_dir = Path('logs')
log_dir.mkdir(exist_ok=True)
log_file = log_dir / 'app.log'
handler = RotatingFileHandler(str(log_file), maxBytes=5 * 1024 * 1024, backupCount=3)
formatter = logging.Formatter('%(asctime)s %(levelname)s %(name)s %(message)s')
handler.setFormatter(formatter)
handler.setLevel(logging.INFO)
app.logger.addHandler(handler)
app.logger.setLevel(logging.INFO)
console = logging.StreamHandler()
console.setFormatter(formatter)
console.setLevel(logging.DEBUG)
app.logger.addHandler(console)
app.logger.info(f"Starting app. SERVE_FOLDER={SERVE_FOLDER}, TEMP_DIR={TEMP_DIR}, UPLOAD_FOLDER={UPLOAD_FOLDER}")
app.logger.info(f"Allowed extensions: {ALLOWED_EXTENSIONS}")
atexit.register(lambda: shutil.rmtree(TEMP_DIR, ignore_errors=True))
def zip_folder(folder_path, zip_path):
    app.logger.info(f"Zipping folder {folder_path} -> {zip_path}")
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, _, files in os.walk(folder_path):
            for file in files:
                file_path = Path(root) / file
                arcname = file_path.relative_to(folder_path)
                zipf.write(file_path, arcname)
def get_file_tree(base_path, current_path=None, depth=0):
    current_path = current_path or base_path
    file_tree = []
    try:
        for item in sorted(os.listdir(current_path)):
            full_path = current_path / item
            relative_path = full_path.relative_to(base_path)
            if full_path.is_dir():
                file_tree.append({
                    'name': item,
                    'path': str(relative_path),
                    'type': 'directory',
                    'depth': depth,
                    'children': get_file_tree(base_path, full_path, depth + 1)
                })
            else:
                try:
                    size = os.path.getsize(full_path)
                except OSError:
                    size = None
                file_tree.append({
                    'name': item,
                    'path': str(relative_path),
                    'type': 'file',
                    'size': size,
                    'depth': depth
                })
    except (FileNotFoundError, PermissionError) as e:
        app.logger.warning(f"get_file_tree error for {current_path}: {e}")
    except Exception as e:
        app.logger.exception(f"Unexpected error in get_file_tree for {current_path}: {e}")
    return file_tree
def is_allowed_file(filename):
    return Path(filename).suffix.lower() in ALLOWED_EXTENSIONS
def safe_resolve_join(base: Path, *parts) -> Path:
    """
    Join parts onto base, resolve, and ensure resulting path is under base.
    Returns resolved path or raises ValueError.
    """
    candidate = (base.joinpath(*parts)).resolve()
    base_resolved = base.resolve()
    try:
        if not str(candidate).startswith(str(base_resolved)):
            raise ValueError(f"Resolved path {candidate} is outside of base {base_resolved}")
    except Exception as e:
        raise
    return candidate
@app.route('/')
def list_files():
    try:
        file_tree = get_file_tree(SERVE_FOLDER)
        app.logger.info("Serving file browser root")
        return render_template('browser.html', files=file_tree, root_path=SERVE_FOLDER.name)
    except FileNotFoundError:
        app.logger.error(f"Directory not found: {SERVE_FOLDER}")
        return render_template('error.html', message=f"Directory '{SERVE_FOLDER}' not found."), 404
    except Exception as e:
        app.logger.exception("Unhandled error listing files")
        return render_template('error.html', message=str(e)), 500
@app.route('/files/<path:filename>')
def serve_file(filename):
    try:
        filepath = (SERVE_FOLDER / filename).resolve()
        app.logger.info(f"Request for file: {filename} -> {filepath}")
        if not str(filepath).startswith(str(SERVE_FOLDER.resolve())):
            app.logger.warning(f"Forbidden file access attempt: {filepath}")
            abort(403)
        if filepath.is_file():
            return send_file(filepath)
        app.logger.warning(f"File not found: {filepath}")
        abort(404)
    except Exception as e:
        app.logger.exception(f"Error serving file {filename}: {e}")
        abort(500)
@app.route('/download-folder/<path:foldername>')
def download_folder(foldername):
    try:
        folderpath = (SERVE_FOLDER / foldername).resolve()
        app.logger.info(f"Download request for folder: {foldername} -> {folderpath}")
        if not str(folderpath).startswith(str(SERVE_FOLDER.resolve())):
            app.logger.warning(f"Forbidden folder access attempt: {folderpath}")
            abort(403)
        if not folderpath.is_dir():
            app.logger.warning(f"Folder not found for download: {folderpath}")
            abort(404, "Folder not found")
        zip_filename = f"{folderpath.name}.zip"
        zip_path = TEMP_DIR / zip_filename
        zip_folder(folderpath, zip_path)
        @after_this_request
        def cleanup(response):
            try:
                if zip_path.exists():
                    os.unlink(zip_path)
                    app.logger.info(f"Removed temporary zip {zip_path}")
            except Exception as e:
                app.logger.error(f"Cleanup failed: {e}")
            return response
        return send_file(
            zip_path,
            as_attachment=True,
            download_name=zip_filename,
            mimetype='application/zip'
        )
    except Exception as e:
        app.logger.exception(f"Error creating zip for {foldername}: {e}")
        if 'zip_path' in locals() and zip_path.exists():
            try:
                os.unlink(zip_path)
            except Exception:
                pass
        abort(500, f"Error creating zip file: {str(e)}")
@app.route('/upload', methods=['POST'])
def handle_upload():
    requested_target = request.form.get('path', '').strip()
    app.logger.info(f"Upload request received. form.path={requested_target}. Files keys: {list(request.files.keys())}")
    results = []
    errors = []
    try:
        target_path = safe_resolve_join(Path(UPLOAD_FOLDER), requested_target)
    except Exception as e:
        app.logger.warning(f"Invalid target path provided: {requested_target} | err={e}")
        return jsonify({
            'status': 'error',
            'message': f'Invalid path: {e}',
            'files': [],
            'errors': []
        }), 200 # Return 200, but with a specific 'error' status in the JSON.
    if not str(target_path).startswith(str(Path(UPLOAD_FOLDER).resolve())):
        app.logger.warning(f"Path check failed: target_path={target_path} not under upload folder {UPLOAD_FOLDER}")
        return jsonify({
            'status': 'error',
            'message': 'Invalid path: directory is not allowed.',
            'files': [],
            'errors': []
        }), 200 # Return 200 with an 'error' status in the JSON.
    if not request.files:
        app.logger.info("No files in request")
        return jsonify({
            'status': 'success',
            'message': 'No files were provided.',
            'files': [],
            'errors': []
        }), 200
    for file_key in request.files:
        file = request.files[file_key]
        original_filename = file.filename or ''
        if not file or not original_filename:
            app.logger.warning(f"No file object or empty filename for key {file_key}")
            errors.append({'file': file_key, 'message': 'No file object or empty filename.', 'type': 'error'})
            continue
        filename = secure_filename(original_filename)
        if not is_allowed_file(filename):
            app.logger.info(f"Rejected file due to disallowed extension: {filename}")
            errors.append({'file': filename, 'message': 'File extension is not allowed.', 'type': 'warning'})
            continue
        relative_path = request.form.get(f'{file_key}_path', '').strip()
        try:
            full_path = safe_resolve_join(target_path, relative_path)
            full_path.mkdir(parents=True, exist_ok=True)
            save_path = full_path / filename
            with tempfile.NamedTemporaryFile(prefix=filename + '.', dir=str(full_path), delete=False) as tmpf:
                tmp_name = Path(tmpf.name)
                file.stream.seek(0)
                chunk_size = 8192
                while True:
                    chunk = file.stream.read(chunk_size)
                    if not chunk:
                        break
                    tmpf.write(chunk)
                tmpf.flush()
                os.fsync(tmpf.fileno())
            os.replace(str(tmp_name), str(save_path))
            size = os.path.getsize(save_path)
            results.append({
                'name': filename,
                'path': str(save_path.relative_to(UPLOAD_FOLDER)),
                'size': size
            })
            app.logger.info(f"Saved file: {save_path} ({size} bytes)")
        except Exception as e:
            app.logger.exception(f"Failed saving file {filename} to {save_path}: {e}")
            errors.append({'file': filename, 'message': f'Failed to save: {e}', 'type': 'error'})
            try:
                if 'tmp_name' in locals() and tmp_name.exists():
                    tmp_name.unlink()
            except Exception:
                pass
    if not errors:
        final_status = 'success'
        message = 'All files uploaded successfully.'
    elif len(errors) == len(request.files):
        final_status = 'error'
        message = 'All files failed to upload.'
    else:
        final_status = 'warning'
        message = 'Some files were uploaded, but others failed.'
    return jsonify({
        'status': final_status,
        'message': message,
        'files': results,
        'errors': errors
    }), 200 # Always return 200 so the client can parse the JSON body.
if __name__ == '__main__':
    try:
        app.run(debug=True, host="0.0.0.0", port=8000)
    except Exception as e:
        app.logger.exception(f"App failed to start: {e}")
---

## serveFolder\README.md
# Flask File Server
A self-hosted Flask-based utility for quickly transferring files between machines without needing to set up FTP or SMB shares.
![Screenshot](https://raw.githubusercontent.com/harishkarthiktk/publicUtilities/refs/heads/master/fileServe/docs/Screenshot.png "File Serve with Upload Utility")
---
## Current Features
- **File Browser UI**: Explore folder structure starting from a configurable `serveFolder`
- **Folder Support**: Nested directories are rendered and navigable
- **File Download**: Any listed file can be downloaded via the web UI
- **Drag-and-Drop Upload**: Upload single files or entire folder structures
- **Basic Security**: Prevents directory traversal and unauthorized filesystem access
- **Temp Zip Cleanup**: Folders downloaded as ZIPs are auto-cleaned after delivery
- **File Filtering**: Only files with safe extensions (`.txt`, `.pdf`, `.jpg`, etc.) are accepted during upload
---
## Upcoming Features: Admin Info
> (Planned section to appear at bottom of UI)
- **Total file count**
- **Total storage used**
- **Lifespan indicators** for uploaded files (e.g., "uploaded 3 hours ago")
---
## Planned Security Features
- **Access Token in URL** (e.g. `/?token=abc123`)
- **Optional Upload Password**
- **Rate Limiting or Time-Boxed Access**
- **Access logs and audit trail** (optional)
---
## Planned Functional Features
- **Select and Download Multiple Files as a ZIP**
- **Unzip Uploaded ZIP Archives Automatically**
- **QR Code for easy access from mobile devices**
- **Auto-delete old files** (based on file age or max count)
- **Pagination** of the list when the files and folders in the served folder becomes lot.
- **Search** functionality of quickly finding the file/path being searched in the entire listing.
---
## Installation
1. Clone the repository:
```bash
git clone https://github.com/harishkarthiktk/flask-file-server.git
cd flask-file-server
```
2. Create environment & install dependencies:
```bash
python3 -m venv env
source env/bin/activate
pip install -r requirements.txt
```
3. Run the app:
```bash
python app.py
```
Then open [http://localhost:8000](http://localhost:8000) in your browser.
---
## Configuration
Edit these in `app.py` if needed:
| Variable       | Purpose                        |
|----------------|---------------------------------|
| `SERVE_FOLDER` | Root directory to serve files from |
| `UPLOAD_FOLDER`| Where uploads get stored        |
| `TEMP_DIR`     | Folder used to store temp zips  |
| `port`         | Port number (default `8000`)     |
| `host`         | Set to `0.0.0.0` to allow LAN access |
---
## API Endpoints
| Method | Path                       | Description                      |
|--------|----------------------------|----------------------------------|
| GET    | `/`                        | Show browser UI with files       |
| GET    | `/files/<path>`           | Download single file             |
| GET    | `/download-folder/<path>` | Download folder as ZIP           |
| POST   | `/upload`                 | Upload files/folders             |
---
## Considerations
- This is a utility, not a hardened production tool
- Great for LAN use, secure behind firewall/VPN
- Avoid exposing it directly to the internet without hardening
---

## test_app.py
import io
import os
import zipfile
import pytest
from pathlib import Path
import app
@pytest.fixture
def client(tmp_path):
    serve_folder = tmp_path / "serveFolder"
    temp_dir = tmp_path / "temp_zips"
    serve_folder.mkdir()
    temp_dir.mkdir()
    app.SERVE_FOLDER = serve_folder.resolve()
    app.UPLOAD_FOLDER = app.SERVE_FOLDER
    app.TEMP_DIR = temp_dir.resolve()
    app.app.config['TESTING'] = True
    with app.app.test_client() as client:
        yield client
def test_homepage_lists_files(client):
    test_file = Path(app.SERVE_FOLDER) / "example.txt"
    test_file.write_text("sample content")
    res = client.get("/")
    assert res.status_code == 200
    assert b"example.txt" in res.data
def test_valid_file_download(client):
    f = Path(app.SERVE_FOLDER) / "test.txt"
    f.write_text("hello")
    res = client.get("/files/test.txt")
    assert res.status_code == 200
    assert res.data == b"hello"
def test_invalid_file_path(client):
    res = client.get("/files/../../etc/passwd")
    assert res.status_code == 403
def test_file_not_found(client):
    res = client.get("/files/missing.txt")
    assert res.status_code == 404
def test_folder_download_as_zip(client):
    folder = Path(app.SERVE_FOLDER) / "dir"
    folder.mkdir()
    (folder / "a.txt").write_text("data")
    res = client.get("/download-folder/dir")
    assert res.status_code == 200
    assert res.headers['Content-Type'] == 'application/zip'
    with zipfile.ZipFile(io.BytesIO(res.data)) as z:
        assert "dir/a.txt" in z.namelist()
def test_download_nonexistent_folder(client):
    res = client.get("/download-folder/ghost")
    assert res.status_code == 404
def test_file_upload(client):
    data = {
        'path': '',
        'file_0': (io.BytesIO(b"test upload"), 'uploaded.txt'),
        'file_0_path': ''
    }
    res = client.post("/upload", data=data, content_type='multipart/form-data')
    assert res.status_code == 200
    saved = Path(app.SERVE_FOLDER) / "uploaded.txt"
    assert saved.exists()
    assert saved.read_text() == "test upload"
def test_upload_invalid_path(client):
    data = {
        'path': '../outside',
        'file_0': (io.BytesIO(b"hack"), 'hack.txt'),
        'file_0_path': ''
    }
    res = client.post("/upload", data=data, content_type='multipart/form-data')
    assert res.status_code == 403
def test_secure_filename(client):
    data = {
        'path': '',
        'file_0': (io.BytesIO(b"123"), '../../evil.sh'),
        'file_0_path': ''
    }
    res = client.post("/upload", data=data, content_type='multipart/form-data')
    assert res.status_code == 200
    for path in Path(app.SERVE_FOLDER).rglob("*"):
        assert ".." not in str(path)
def test_temp_zip_cleanup(client):
    folder = Path(app.SERVE_FOLDER) / "tozip"
    folder.mkdir()
    (folder / "one.txt").write_text("zip me")
    zip_path = Path(app.TEMP_DIR) / "tozip.zip"
    if zip_path.exists():
        zip_path.unlink()
    res = client.get("/download-folder/tozip")
    assert res.status_code == 200
    import time
    time.sleep(0.2)
    assert not zip_path.exists()
def test_filtered_mime_type_is_skipped(client):
    data = {
        'path': '',
        'file_0': (io.BytesIO(b"<php?>"), 'malicious.php'),
        'file_0_path': ''
    }
    res = client.post("/upload", data=data, content_type='multipart/form-data')
    assert res.status_code == 200
    found = any("malicious.php" in str(p) for p in Path(app.SERVE_FOLDER).rglob("*"))
    assert not found
---

## templates\base.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Server - {{ root_path }}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            display: flex;
        }
        .main-content {
            flex-grow: 1;
            padding-right: 320px;
        }
        #upload-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background: #f5f5f5;
            border-left: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
        }
        #drop-zone {
            border: 2px dashed #aaa;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 5px;
            transition: all 0.3s;
        }
        #progress-bar {
            height: 20px;
            background: #eee;
            margin-bottom: 10px;
            border-radius: 3px;
            overflow: hidden;
        }
        #progress-indicator {
            height: 100%;
            width: 0%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        #file-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .file-item {
            padding: 5px;
            margin: 3px 0;
            border-bottom: 1px solid #eee;
            font-size: 0.9em;
            word-break: break-word;
        }
        .file-list {
            list-style: none;
            padding-left: 10px;
        }
        .directory-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .directory-header {
            cursor: pointer;
            padding: 3px 0;
            display: flex;
            align-items: center;
            flex-grow: 1;
        }
        .directory-header:hover {
            background-color: #f5f5f5;
        }
        .toggle-icon {
            display: inline-block;
            width: 15px;
            text-align: center;
            font-size: 0.8em;
            color: #666;
            margin-right: 3px;
        }
        .directory-name {
            font-weight: bold;
            color: #2c3e50;
        }
        .download-folder {
            text-decoration: none;
            color: #3498db;
            padding: 0 5px;
            font-size: 0.9em;
        }
        .download-folder:hover {
            color: #2980b9;
        }
        .file {
            color: #7f8c8d;
            display: block;
            padding: 3px 0;
            text-decoration: none;
        }
        .file:hover {
            background-color: #f5f5f5;
        }
        .file-size {
            color: #95a5a6;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .directory-contents {
            list-style: none;
            padding-left: 20px;
            margin: 3px 0;
        }
        .controls {
            margin-bottom: 15px;
        }
        button {
            padding: 5px 10px;
            margin-right: 5px;
            cursor: pointer;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        button:hover {
            background: #e0e0e0;
        }
        input[type="text"] {
            width: 100%;
            padding: 8px;
            margin: 5px 0 15px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        /* Toast CSS */
        #flask-toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2147483647;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
            pointer-events: none;
        }
        .fl-toast {
            min-width: 220px;
            max-width: 420px;
            padding: 10px 14px;
            border-radius: 6px;
            color: white;
            font-family: Arial, Helvetica, sans-serif;
            box-shadow: 0 6px 18px rgba(0,0,0,0.18);
            opacity: 0;
            transform: translateY(-8px);
            transition: opacity 220ms ease, transform 220ms ease;
            pointer-events: auto;
        }
        .fl-toast.show { opacity: 1; transform: translateY(0); }
        .fl-toast.success { background: #2e8b57; }
        .fl-toast.warning { background: #2b6cb0; }
        .fl-toast.error { background: #c53030; }
        .fl-toast .title { font-weight: 700; margin-bottom: 6px; font-size: 13px; }
        .fl-toast .msg { font-size: 13px; line-height: 1.2; opacity: 0.95; white-space: pre-wrap; }
        .fl-toast .close-btn {
            position: absolute;
            top: 6px;
            right: 8px;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.9);
            font-size: 14px;
            cursor: pointer;
        }
        .fl-toast-wrapper {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="main-content">
        <h1>File Server: {{ root_path }}</h1>
        <div class="controls">
            <button onclick="collapseAll()">Collapse All</button>
            <button onclick="expandFirstLevel()">Expand First Level</button>
        </div>
        {% block content %}{% endblock %}
    </div>
    <div id="upload-panel">
        <h3>Upload Files</h3>
        <div id="drop-zone">
            Drag & Drop Files or Folders Here
        </div>
        <div id="path-selector" style="display:none;">
            <label>Target Path:</label>
            <input type="text" id="upload-path" value="" placeholder="subfolder/path">
            <button id="upload-btn">Upload</button>
        </div>
        <div id="upload-progress" style="display:none;">
            <div id="progress-bar">
                <div id="progress-indicator"></div>
            </div>
            <div id="progress-text">Preparing upload...</div>
            <div id="file-list"></div>
        </div>
    </div>
    <div id="flask-toast-container"></div>
    <script>
    // File browser logic
    function collapseAll() {
        document.querySelectorAll('.directory-contents').forEach(el => {
            el.style.display = 'none';
        });
        document.querySelectorAll('.toggle-icon').forEach(el => {
            el.textContent = '‚ñ∂';
        });
    }
    function expandFirstLevel() {
        collapseAll();
        document.querySelectorAll('.directory-item > .directory-contents').forEach(el => {
            el.style.display = 'block';
            el.previousElementSibling.querySelector('.toggle-icon').textContent = '‚ñº';
        });
    }
    // --- Start of Toast and Upload Logic ---
    // 1. Toast System Logic
    function escapeHtml(str) {
        if (str == null) return '';
        return String(str)
            .replaceAll('&', '&amp;')
            .replaceAll('<', '&lt;')
            .replaceAll('>', '&gt;')
            .replaceAll('"', '&quot;')
            .replaceAll("'", '&#39;');
    }
    function showToast(message, type = 'success', title = '', duration = 4000) {
        const container = document.getElementById('flask-toast-container');
        const elWrap = document.createElement('div');
        elWrap.className = 'fl-toast-wrapper';
        const el = document.createElement('div');
        el.className = `fl-toast ${type}`;
        if (title) {
            el.innerHTML = `<div class="title">${escapeHtml(title)}</div><div class="msg">${escapeHtml(message)}</div>`;
        } else {
            el.innerHTML = `<div class="msg">${escapeHtml(message)}</div>`;
        }
        const closeBtn = document.createElement('button');
        closeBtn.className = 'close-btn';
        closeBtn.innerHTML = '&times;';
        closeBtn.onclick = () => removeToast(elWrap);
        elWrap.appendChild(el);
        elWrap.appendChild(closeBtn);
        container.appendChild(elWrap);
        requestAnimationFrame(() => el.classList.add('show'));
        if (duration > 0) {
            setTimeout(() => removeToast(elWrap), duration);
        }
    }
    function removeToast(elWrap) {
        try {
            const toast = elWrap.querySelector('.fl-toast');
            if (toast) toast.classList.remove('show');
            setTimeout(() => {
                if (elWrap.parentNode) elWrap.parentNode.removeChild(elWrap);
            }, 240);
        } catch (e) {
            try { if (elWrap.parentNode) elWrap.parentNode.removeChild(elWrap); } catch (e2) {}
        }
    }
    // 2. Upload Logic
    document.addEventListener('DOMContentLoaded', () => {
        const dropZone = document.getElementById('drop-zone');
        const pathInput = document.getElementById('upload-path');
        const pathSelector = document.getElementById('path-selector');
        const uploadProgressBlock = document.getElementById('upload-progress');
        const progressIndicator = document.getElementById('progress-indicator');
        const progressText = document.getElementById('progress-text');
        const fileListEl = document.getElementById('file-list');
        const uploadBtn = document.getElementById('upload-btn');
        let filesToUpload = [];
        if (!dropZone) return;
        dropZone.addEventListener('click', (e) => {
            e.stopPropagation();
            pathSelector.style.display = pathSelector.style.display === 'none' ? 'block' : 'none';
        });
        ['dragenter', 'dragover'].forEach(evt => {
            dropZone.addEventListener(evt, (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.style.borderColor = '#3498db';
                dropZone.style.background = '#fbfcfe';
            });
        });
        ['dragleave', 'drop', 'dragend'].forEach(evt => {
            dropZone.addEventListener(evt, (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.style.borderColor = '#aaa';
                dropZone.style.background = '';
            });
        });
        // Store files on drop, don't start upload
        dropZone.addEventListener('drop', (e) => {
            const items = e.dataTransfer.files;
            if (!items || items.length === 0) return;
            filesToUpload = Array.from(items);
            showFileList(filesToUpload);
        });
        if (uploadBtn) {
            uploadBtn.addEventListener('click', () => {
                if (filesToUpload.length > 0) {
                    handleFiles(filesToUpload);
                } else {
                    showToast('No files to upload. Please drag and drop files first.', 'warning', 'No Files');
                }
            });
        }
        window.startUpload = function () {
            const inp = document.createElement('input');
            inp.type = 'file';
            inp.multiple = true;
            inp.webkitdirectory = true;
            inp.onchange = () => {
                if (inp.files && inp.files.length) {
                    filesToUpload = Array.from(inp.files);
                    showFileList(filesToUpload);
                }
            };
            inp.click();
        };
        function showFileList(files) {
            uploadProgressBlock.style.display = 'block';
            fileListEl.innerHTML = files.map(f => `<div class="file-item">${escapeHtml(f.name)} <span class="file-size">(${f.size} bytes)</span></div>`).join('');
            progressIndicator.style.width = '0%';
            progressText.textContent = `Ready to upload ${files.length} file(s).`;
        }
        function handleFiles(files) {
            if (!files.length) return;
            progressIndicator.style.width = '0%';
            progressText.textContent = `Preparing ${files.length} file(s)...`;
            const fd = new FormData();
            files.forEach((f, idx) => {
                fd.append(`file_${idx}`, f, f.name);
            });
            const requestedPath = (pathInput && pathInput.value) ? pathInput.value.trim() : '';
            if (requestedPath) fd.append('path', requestedPath);
            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/upload', true);
            xhr.upload.onprogress = function (evt) {
                if (evt.lengthComputable) {
                    const percent = Math.round((evt.loaded / evt.total) * 100);
                    progressIndicator.style.width = percent + '%';
                    progressText.textContent = `Uploading: ${percent}%`;
                } else {
                    progressText.textContent = `Uploading...`;
                }
            };
            xhr.onload = function () {
                let response;
                try {
                    response = JSON.parse(xhr.responseText);
                } catch (e) {
                    showToast('Upload completed, but the server response was invalid.', 'error', 'Upload Error');
                    return;
                }
                const { status, message, files: uploadedFiles, errors } = response;
                if (status === 'success') {
                    showToast(message, 'success', 'Upload Successful');
                } else if (status === 'warning') {
                    showToast(message, 'warning', 'Partial Upload');
                    if (Array.isArray(errors)) {
                        errors.forEach(err => {
                            showToast(`${err.file}: ${err.message}`, 'error', 'File Error');
                        });
                    }
                } else if (status === 'error') {
                    showToast(message || 'An unknown error occurred.', 'error', 'Upload Failed');
                }
                progressIndicator.style.width = '100%';
                progressText.textContent = 'Upload finished';
                // Clear the files after a successful or failed upload
                filesToUpload = [];
                setTimeout(() => {
                    uploadProgressBlock.style.display = 'none';
                    progressIndicator.style.width = '0%';
                }, 1800);
            };
            xhr.onerror = function () {
                showToast('The upload failed due to a network error.', 'error', 'Network Error');
                uploadProgressBlock.style.display = 'none';
            };
            xhr.send(fd);
        }
    });
    </script>
</body>
</html>
---

## templates\browser.html
{% extends "base.html" %}
{% block content %}
<ul class="file-list" id="fileTree">
    {% for item in files %}
        <li class="{{ 'directory-item' if item.type == 'directory' else 'file-item' }}" data-path="{{ item.path | urlencode }}">
            {% if item.type == 'directory' %}
                <div class="directory-container">
                    <div class="directory-header" onclick="toggleDirectory(event, this)">
                        <span class="toggle-icon">‚ñ∂</span>
                        <span class="directory-name">üìÅ {{ item.name }}/</span>
                    </div>
                    <a href="/download-folder/{{ item.path | urlencode }}" class="download-folder" title="Download entire folder" onclick="event.stopPropagation()">
                        ‚¨áÔ∏è
                    </a>
                </div>
                <ul class="directory-contents" style="display: none;">
                    {% for child in item.children %}
                        <li class="{{ 'directory-item' if child.type == 'directory' else 'file-item' }}" data-path="{{ child.path | urlencode }}">
                            {% if child.type == 'directory' %}
                                <div class="directory-container">
                                    <div class="directory-header" onclick="toggleDirectory(event, this)">
                                        <span class="toggle-icon">‚ñ∂</span>
                                        <span class="directory-name">üìÅ {{ child.name }}/</span>
                                    </div>
                                    <a href="/download-folder/{{ child.path | urlencode }}" class="download-folder" title="Download entire folder" onclick="event.stopPropagation()">
                                        ‚¨áÔ∏è
                                    </a>
                                </div>
                                <ul class="directory-contents" style="display: none;"></ul>
                            {% else %}
                                <a href="/files/{{ child.path | urlencode }}" class="file" download>
                                    üìÑ {{ child.name }}
                                    <span class="file-size">({{ child.size | filesizeformat }})</span>
                                </a>
                            {% endif %}
                        </li>
                    {% endfor %}
                </ul>
            {% else %}
                <a href="/files/{{ item.path | urlencode }}" class="file" download>
                    üìÑ {{ item.name }}
                    <span class="file-size">({{ item.size | filesizeformat }})</span>
                </a>
            {% endif %}
        </li>
    {% endfor %}
</ul>
<script>
document.addEventListener("DOMContentLoaded", function () {
    let filesToUpload = [];
    let xhr = null;
    function formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    const dropZone = document.getElementById('drop-zone');
    const pathSelector = document.getElementById('path-selector');
    const uploadProgress = document.getElementById('upload-progress');
    document.addEventListener('dragover', e => e.preventDefault());
    document.addEventListener('drop', e => e.preventDefault());
    dropZone.addEventListener('dragover', e => {
        e.preventDefault();
        dropZone.style.borderColor = '#4CAF50';
        dropZone.style.backgroundColor = '#f0fff0';
    });
    dropZone.addEventListener('dragleave', () => {
        dropZone.style.borderColor = '#aaa';
        dropZone.style.backgroundColor = '';
    });
    dropZone.addEventListener('drop', async e => {
        e.preventDefault();
        dropZone.style.borderColor = '#aaa';
        dropZone.style.backgroundColor = '';
        filesToUpload = [];
        const items = e.dataTransfer.items;
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file') {
                const entry = item.webkitGetAsEntry();
                if (entry) {
                    if (entry.isFile) {
                        const file = await getFileFromEntry(entry);
                        filesToUpload.push({ file, path: '', name: file.name });
                    } else if (entry.isDirectory) {
                        await processDirectory(entry, '');
                    }
                }
            }
        }
        if (filesToUpload.length > 0) {
            pathSelector.style.display = 'block';
            document.getElementById('upload-path').value = '';
        } else {
            alert('No valid files were found in the drop');
        }
    });
    function getFileFromEntry(entry) {
        return new Promise(resolve => entry.file(resolve));
    }
    async function processDirectory(directory, path) {
        const reader = directory.createReader();
        const entries = await new Promise(resolve => reader.readEntries(resolve));
        for (const entry of entries) {
            if (entry.isFile) {
                const file = await getFileFromEntry(entry);
                filesToUpload.push({ file, path: path + directory.name + '/', name: entry.name });
            } else if (entry.isDirectory) {
                await processDirectory(entry, path + directory.name + '/');
            }
        }
    }
    window.startUpload = function () {
        const targetPath = document.getElementById('upload-path').value.trim();
        uploadProgress.style.display = 'block';
        pathSelector.style.display = 'none';
        const formData = new FormData();
        formData.append('path', targetPath);
        filesToUpload.forEach((fileObj, index) => {
            formData.append(`file_${index}`, fileObj.file);
            formData.append(`file_${index}_path`, fileObj.path);
        });
        if (xhr) xhr.abort();
        xhr = new XMLHttpRequest();
        xhr.open('POST', '/upload', true);
        xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
                const percent = Math.round((e.loaded / e.total) * 100);
                document.getElementById('progress-indicator').style.width = percent + '%';
                document.getElementById('progress-text').textContent =
                    `Uploading... ${percent}% (${formatBytes(e.loaded)} of ${formatBytes(e.total)})`;
            }
        };
        xhr.onload = function () {
            if (this.status === 200) {
                try {
                    const response = JSON.parse(this.responseText);
                    updateFileList(response.files);
                    document.getElementById('progress-text').textContent = 'Upload complete!';
                    setTimeout(() => window.location.reload(), 2000);
                } catch (e) {
                    console.error('Error parsing response:', e);
                }
            } else {
                document.getElementById('progress-text').textContent = 'Upload failed';
            }
        };
        xhr.onerror = () => document.getElementById('progress-text').textContent = 'Upload error occurred';
        xhr.send(formData);
    }
    function updateFileList(files) {
        const fileList = document.getElementById('file-list');
        fileList.innerHTML = '';
        files.forEach(file => {
            const div = document.createElement('div');
            div.className = 'file-item';
            div.textContent = `${file.path}${file.name} (${formatBytes(file.size)})`;
            fileList.appendChild(div);
        });
    }
    window.toggleDirectory = function (event, element) {
        if (event.target.closest('.download-folder')) return;
        const contents = element.closest('.directory-container').nextElementSibling;
        const icon = element.querySelector('.toggle-icon');
        if (contents.style.display === 'none') {
            contents.style.display = 'block';
            icon.textContent = '‚ñº';
        } else {
            contents.style.display = 'none';
            icon.textContent = '‚ñ∂';
        }
    }
    window.addEventListener('beforeunload', () => {
        if (xhr && xhr.readyState !== XMLHttpRequest.DONE) xhr.abort();
    });
});
</script>
{% endblock %}
---

## templates\error.html
{% extends "base.html" %}
{% block content %}
<div class="error">
    <h2>Error</h2>
    <p>{{ message }}</p>
</div>
{% endblock %}
---

## serveFolder\script.sh
#!/bin/bash
---
